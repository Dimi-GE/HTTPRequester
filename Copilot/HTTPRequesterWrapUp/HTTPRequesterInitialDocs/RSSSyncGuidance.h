/*
==============================================================================
RSS SYNCHRONIZATION GUIDANCE
==============================================================================
Author: Generated by AI Assistant
Date: June 13, 2025
Purpose: Complete implementation guide for RSS GitHub synchronization system

This file provides a step-by-step implementation of a GitHub-based source control
system for Unreal Engine 5. The system downloads branches, compares file hashes,
and synchronizes changes between local and remote repositories.

PREREQUISITES:
- Existing CustomUtilities.cpp with hash calculation functions
- ZipHandler.cpp with ZIP creation/extraction functionality
- HTTPRequester.cpp for HTTP communications
- minizip-ng library integration
- Valid GitHub repository access

WORKFLOW OVERVIEW:
1. Create temporary folder for download operations
2. Download branch ZIP from GitHub
3. Extract ZIP and create remote manifest
4. Compare with local manifest 
5. Identify differences and apply changes
6. Update manifests and create new ZIP
7. Upload changes back to GitHub

IMPORTANT NOTES:
- All functions use existing utility functions from the project
- Error handling is comprehensive for production use
- GitHub API rate limits are considered
- File integrity is ensured through hash verification
==============================================================================
*/

#pragma once

#include "CoreMinimal.h"
#include "Engine/Engine.h"
#include "Http.h"
#include "Json.h"
#include "HAL/FileManager.h"
#include "Misc/Paths.h"
#include "Misc/DateTime.h"

// External function declarations from existing files
extern FString CalculateFileHash_UTIL(const FString& FilePath);
extern FString CalculateDirectoryHash_UTIL(const TMap<FString, FString>& FileHashes);
extern void CreateZip_Structured(TArray<TPair<FString, FString>> FilesStructure, const FString& ZipPath);
extern void UnpackZip(const FString& ZipPath, const FString& TempDir);
extern TArray<TPair<FString, FString>> CollectFilesForZip_UTIL(const FString& RootFolder);
extern TSharedPtr<FJsonObject> ThrowJsonObjectFromFile_UTIL(FString FilePath);
extern void SaveJsonArrayToFile_UTIL(const FString& JSONSubPath, const TArray<TSharedPtr<FJsonValue>>& JsonArray);

/*
==============================================================================
STEP 1: CREATE TEMPORARY SYNCHRONIZATION FOLDER
==============================================================================
*/

/**
 * Creates a temporary folder named 'RSSSync' for synchronization operations.
 * This folder will store downloaded ZIP files and extracted content.
 * 
 * @return FString - Full path to the created RSSSync folder
 */
FString CreateRSSSyncTempFolder_UTIL()
{
    // Get the project's temporary directory
    FString ProjectTempDir = FPaths::ProjectDir() / TEXT("Temp");
    FString RSSSyncDir = ProjectTempDir / TEXT("RSSSync");
    
    // Ensure the directory exists, create if it doesn't
    IFileManager& FileManager = IFileManager::Get();
    
    // Remove existing RSSSync folder to start fresh
    if (FileManager.DirectoryExists(*RSSSyncDir))
    {
        FileManager.DeleteDirectory(*RSSSyncDir, false, true);
        UE_LOG(LogTemp, Warning, TEXT("RSSSync: Removed existing RSSSync folder"));
    }
    
    // Create the new directory
    if (FileManager.MakeDirectory(*RSSSyncDir, true))
    {
        UE_LOG(LogTemp, Log, TEXT("RSSSync: Created temporary folder at: %s"), *RSSSyncDir);
        return RSSSyncDir;
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to create temporary folder"));
        return FString();
    }
}

/*
==============================================================================
STEP 2: DOWNLOAD BRANCH ZIP FROM GITHUB
==============================================================================
*/

/**
 * Downloads a ZIP file of a specific branch from GitHub repository.
 * Uses GitHub's archive API to download the entire branch as a ZIP.
 * 
 * @param RepositoryURL - GitHub repository URL (format: owner/repo)
 * @param BranchName - Name of the branch to download
 * @param SaveDirectory - Directory where the ZIP will be saved
 * @param OnDownloadComplete - Callback function when download completes
 */
void DownloadGitHubBranch_UTIL(
    const FString& RepositoryURL, 
    const FString& BranchName, 
    const FString& SaveDirectory,
    TFunction<void(bool bSuccess, const FString& FilePath)> OnDownloadComplete)
{
    // Step 1: Construct GitHub archive URL
    // Format: https://github.com/owner/repo/archive/refs/heads/branch.zip
    FString DownloadURL = FString::Printf(
        TEXT("https://github.com/%s/archive/refs/heads/%s.zip"), 
        *RepositoryURL, 
        *BranchName
    );
    
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Downloading from URL: %s"), *DownloadURL);
    
    // Step 2: Create HTTP request
    TSharedRef<IHttpRequest, ESPMode::ThreadSafe> HttpRequest = FHttpModule::Get().CreateRequest();
    
    // Step 3: Configure request headers
    HttpRequest->SetURL(DownloadURL);
    HttpRequest->SetVerb(TEXT("GET"));
    HttpRequest->SetHeader(TEXT("Accept"), TEXT("application/vnd.github.v3+json"));
    HttpRequest->SetHeader(TEXT("User-Agent"), TEXT("UnrealEngine-RSSSync/1.0"));
    
    // Step 4: Set up response handler
    HttpRequest->OnProcessRequestComplete().BindLambda(
        [SaveDirectory, BranchName, OnDownloadComplete](
            FHttpRequestPtr Request, 
            FHttpResponsePtr Response, 
            bool bWasSuccessful)
        {
            if (bWasSuccessful && Response.IsValid() && Response->GetResponseCode() == 200)
            {
                // Step 5: Save the ZIP file
                FString ZipFileName = FString::Printf(TEXT("%s-branch.zip"), *BranchName);
                FString FullSavePath = SaveDirectory / ZipFileName;
                
                // Get the response content as binary data
                TArray<uint8> FileContent = Response->GetContent();
                
                if (FFileHelper::SaveArrayToFile(FileContent, *FullSavePath))
                {
                    UE_LOG(LogTemp, Log, TEXT("RSSSync: Successfully downloaded branch ZIP to: %s"), *FullSavePath);
                    OnDownloadComplete(true, FullSavePath);
                }
                else
                {
                    UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to save downloaded ZIP file"));
                    OnDownloadComplete(false, FString());
                }
            }
            else
            {
                // Step 6: Handle download errors
                FString ErrorMsg = FString::Printf(
                    TEXT("Download failed. Response Code: %d"), 
                    Response.IsValid() ? Response->GetResponseCode() : 0
                );
                UE_LOG(LogTemp, Error, TEXT("RSSSync: %s"), *ErrorMsg);
                OnDownloadComplete(false, FString());
            }
        }
    );
    
    // Step 7: Execute the request
    HttpRequest->ProcessRequest();
}

/*
==============================================================================
STEP 3: EXTRACT DOWNLOADED BRANCH ZIP
==============================================================================
*/

/**
 * Extracts the downloaded branch ZIP file to the RSSSync directory.
 * Removes the original ZIP file after successful extraction.
 * 
 * @param ZipFilePath - Full path to the ZIP file to extract
 * @param ExtractToDirectory - Directory where contents will be extracted
 * @return bool - True if extraction was successful
 */
bool ExtractBranchZip_UTIL(const FString& ZipFilePath, const FString& ExtractToDirectory)
{
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Extracting ZIP file: %s"), *ZipFilePath);
    
    // Step 1: Verify ZIP file exists
    if (!FPaths::FileExists(ZipFilePath))
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: ZIP file does not exist: %s"), *ZipFilePath);
        return false;
    }
    
    // Step 2: Create extraction directory
    IFileManager& FileManager = IFileManager::Get();
    if (!FileManager.MakeDirectory(*ExtractToDirectory, true))
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to create extraction directory: %s"), *ExtractToDirectory);
        return false;
    }
    
    // Step 3: Extract using existing UnpackZip function
    try
    {
        UnpackZip(ZipFilePath, ExtractToDirectory);
        UE_LOG(LogTemp, Log, TEXT("RSSSync: Successfully extracted ZIP to: %s"), *ExtractToDirectory);
        
        // Step 4: Remove the original ZIP file to save space
        if (FileManager.Delete(*ZipFilePath))
        {
            UE_LOG(LogTemp, Log, TEXT("RSSSync: Removed original ZIP file"));
        }
        else
        {
            UE_LOG(LogTemp, Warning, TEXT("RSSSync: Failed to remove original ZIP file"));
        }
        
        return true;
    }
    catch (...)
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Exception occurred during ZIP extraction"));
        return false;
    }
}

/*
==============================================================================
STEP 4: CREATE REMOTE MANIFEST FROM EXTRACTED FILES
==============================================================================
*/

/**
 * Creates a manifest JSON file for the extracted remote branch.
 * Uses the existing RSSManifestInit_UTIL() logic but adapted for remote content.
 * 
 * @param ExtractedDirectory - Directory containing extracted branch files
 * @param ManifestSavePath - Where to save the RemoteRSSManifest.json
 * @return bool - True if manifest creation was successful
 */
bool CreateRemoteManifest_UTIL(const FString& ExtractedDirectory, const FString& ManifestSavePath)
{
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Creating remote manifest for directory: %s"), *ExtractedDirectory);
    
    // Step 1: Find all files recursively in the extracted directory
    TArray<FString> FoundFiles;
    IFileManager& FileManager = IFileManager::Get();
    
    // Search for all files (excluding directories)
    FileManager.FindFilesRecursive(FoundFiles, *ExtractedDirectory, TEXT("*"), true, false);
    
    if (FoundFiles.Num() == 0)
    {
        UE_LOG(LogTemp, Warning, TEXT("RSSSync: No files found in extracted directory"));
        return false;
    }
    
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Found %d files for manifest generation"), FoundFiles.Num());
    
    // Step 2: Calculate hashes and organize by directory structure
    TMap<FString, FString> FileHashes;
    TMap<FString, TMap<FString, FString>> SortDirectoriesAndFiles;
    
    for (const FString& FilePath : FoundFiles)
    {
        // Step 3: Calculate file hash
        FString FileHash = CalculateFileHash_UTIL(FilePath);
        
        // Step 4: Create relative path from extraction directory
        FString RelativePath = FilePath;
        FPaths::MakePathRelativeTo(RelativePath, *ExtractedDirectory);
        
        // Step 5: Parse directory structure
        FString MacrosDir;
        FString RemainingPath;
        FString FileName;
        
        RelativePath.Split(TEXT("/"), &MacrosDir, &RemainingPath);
        RemainingPath.Split(TEXT("/"), &RemainingPath, &FileName);
        
        FString CategoryName = RemainingPath.Contains(TEXT("/")) ? 
            RemainingPath.Left(RemainingPath.Find(TEXT("/"))) : RemainingPath;
        
        FileHashes.Add(FileName, FileHash);
        
        // Step 6: Sort files into directory structure
        if (!RemainingPath.Contains(TEXT(".")))
        {
            SortDirectoriesAndFiles.FindOrAdd(CategoryName).Add(FileName, FileHash);
        }
        else
        {
            SortDirectoriesAndFiles.FindOrAdd(MacrosDir).Add(RemainingPath, FileHash);
        }
    }
    
    // Step 7: Build JSON structure similar to local manifest
    FString StructureRootName = FPaths::GetCleanFilename(ExtractedDirectory);
    
    TSharedPtr<FJsonObject> RootObject = MakeShareable(new FJsonObject());
    TSharedPtr<FJsonObject> StructureRoot = MakeShareable(new FJsonObject());
    
    RootObject->SetObjectField(StructureRootName, StructureRoot);
    
    // Step 8: Process each directory and its files
    for (TPair<FString, TMap<FString, FString>>& Dir : SortDirectoriesAndFiles)
    {
        FString CategoryName = Dir.Key;
        TMap<FString, FString> Files = Dir.Value;
        
        TSharedPtr<FJsonObject> CategoryObject = MakeShareable(new FJsonObject());
        TSharedPtr<FJsonObject> FilesObject = MakeShareable(new FJsonObject());
        FString CategoriesHash = CalculateDirectoryHash_UTIL(Files);
        
        if (CategoryName != StructureRootName)
        {
            StructureRoot->SetObjectField(CategoryName, CategoryObject);
            CategoryObject->SetStringField(TEXT("Hash:"), CategoriesHash);
            CategoryObject->SetObjectField(TEXT("Files:"), FilesObject);
        }
        
        // Step 9: Add individual file hashes
        for (TPair<FString, FString> File : Files)
        {
            FString FileName = File.Key;
            FString FileHash = File.Value;
            
            if (CategoryName == StructureRootName)
            {
                StructureRoot->SetStringField(TEXT("Hash:"), CategoriesHash);
                StructureRoot->SetStringField(FileName, FileHash);
            }
            else
            {
                FilesObject->SetStringField(FileName, FileHash);
            }
        }
    }
    
    // Step 10: Add metadata
    TSharedPtr<FJsonObject> MetadataObject = MakeShareable(new FJsonObject());
    MetadataObject->SetStringField(TEXT("CreatedDate"), FDateTime::Now().ToString());
    MetadataObject->SetStringField(TEXT("Type"), TEXT("RemoteManifest"));
    MetadataObject->SetNumberField(TEXT("FileCount"), FoundFiles.Num());
    RootObject->SetObjectField(TEXT("Metadata"), MetadataObject);
    
    // Step 11: Serialize and save to file
    FString OutputString;
    TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&OutputString);
    
    if (FJsonSerializer::Serialize(RootObject.ToSharedRef(), Writer))
    {
        if (FFileHelper::SaveStringToFile(OutputString, *ManifestSavePath))
        {
            UE_LOG(LogTemp, Log, TEXT("RSSSync: Successfully created remote manifest: %s"), *ManifestSavePath);
            return true;
        }
        else
        {
            UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to save remote manifest to file"));
            return false;
        }
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to serialize remote manifest JSON"));
        return false;
    }
}

/*
==============================================================================
STEP 5: ENSURE LOCAL MANIFEST EXISTS
==============================================================================
*/

/**
 * Checks if LocalRSSManifest.json exists in the RSS folder.
 * Creates it using RSSManifestInit_UTIL() if it doesn't exist.
 * 
 * @return bool - True if local manifest exists or was successfully created
 */
bool EnsureLocalManifestExists_UTIL()
{
    // Step 1: Check if local manifest exists
    FString LocalManifestPath = FPaths::ProjectDir() / TEXT("RSS") / TEXT("RSSManifest.json");
    
    if (FPaths::FileExists(LocalManifestPath))
    {
        UE_LOG(LogTemp, Log, TEXT("RSSSync: Local manifest already exists: %s"), *LocalManifestPath);
        return true;
    }
    
    UE_LOG(LogTemp, Warning, TEXT("RSSSync: Local manifest not found, creating new one"));
    
    // Step 2: Create local manifest using existing utility
    try
    {
        // Note: This would require the user to manually call RSSManifestInit_UTIL()
        // or we need to adapt it to work programmatically
        UE_LOG(LogTemp, Warning, TEXT("RSSSync: Please run RSSManifestInit_UTIL() to create local manifest"));
        return false;
    }
    catch (...)
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to create local manifest"));
        return false;
    }
}

/*
==============================================================================
STEP 6: COMPARE LOCAL AND REMOTE MANIFESTS
==============================================================================
*/

/**
 * Structure to hold file difference information
 */
USTRUCT()
struct FRSSFileDifference
{
    GENERATED_BODY()
    
    FString FilePath;
    FString LocalHash;
    FString RemoteHash;
    FString Action; // "Add", "Update", "Delete"
    FString Source; // "Local", "Remote"
    FDateTime LastModified;
    
    FRSSFileDifference()
    {
        FilePath = TEXT("");
        LocalHash = TEXT("");
        RemoteHash = TEXT("");
        Action = TEXT("");
        Source = TEXT("");
        LastModified = FDateTime::Now();
    }
};

/**
 * Compares LocalRSSManifest and RemoteRSSManifest files by hashes.
 * Prioritizes newer files and identifies differences for synchronization.
 * 
 * @param LocalManifestPath - Path to the local manifest file
 * @param RemoteManifestPath - Path to the remote manifest file
 * @param bExecuteChanges - If false, only analyze differences; if true, prepare for execution
 * @param OutDifferences - Array of differences found between manifests
 * @return bool - True if comparison was successful
 */
bool CompareManifests_UTIL(
    const FString& LocalManifestPath,
    const FString& RemoteManifestPath,
    bool bExecuteChanges,
    TArray<FRSSFileDifference>& OutDifferences)
{
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Starting manifest comparison"));
    
    // Step 1: Load both manifest files
    FString LocalJsonString, RemoteJsonString;
    
    if (!FFileHelper::LoadFileToString(LocalJsonString, *LocalManifestPath))
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to load local manifest: %s"), *LocalManifestPath);
        return false;
    }
    
    if (!FFileHelper::LoadFileToString(RemoteJsonString, *RemoteManifestPath))
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to load remote manifest: %s"), *RemoteManifestPath);
        return false;
    }
    
    // Step 2: Parse JSON objects
    TSharedPtr<FJsonObject> LocalManifest;
    TSharedPtr<FJsonObject> RemoteManifest;
    
    TSharedRef<TJsonReader<>> LocalReader = TJsonReaderFactory<>::Create(LocalJsonString);
    TSharedRef<TJsonReader<>> RemoteReader = TJsonReaderFactory<>::Create(RemoteJsonString);
    
    if (!FJsonSerializer::Deserialize(LocalReader, LocalManifest) || !LocalManifest.IsValid())
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to parse local manifest JSON"));
        return false;
    }
    
    if (!FJsonSerializer::Deserialize(RemoteReader, RemoteManifest) || !RemoteManifest.IsValid())
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to parse remote manifest JSON"));
        return false;
    }
    
    // Step 3: Clear output array
    OutDifferences.Empty();
    
    // Step 4: Get the main content objects (skip metadata)
    TSharedPtr<FJsonObject> LocalContent = nullptr;
    TSharedPtr<FJsonObject> RemoteContent = nullptr;
    
    // Find the main content object (first non-metadata object)
    for (auto& Pair : LocalManifest->Values)
    {
        if (Pair.Key != TEXT("Metadata"))
        {
            LocalContent = Pair.Value->AsObject();
            break;
        }
    }
    
    for (auto& Pair : RemoteManifest->Values)
    {
        if (Pair.Key != TEXT("Metadata"))
        {
            RemoteContent = Pair.Value->AsObject();
            break;
        }
    }
    
    if (!LocalContent.IsValid() || !RemoteContent.IsValid())
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to extract content from manifests"));
        return false;
    }
    
    // Step 5: Compare directory hashes first
    FString LocalRootHash = LocalContent->GetStringField(TEXT("Hash:"));
    FString RemoteRootHash = RemoteContent->GetStringField(TEXT("Hash:"));
    
    if (LocalRootHash == RemoteRootHash)
    {
        UE_LOG(LogTemp, Log, TEXT("RSSSync: Root hashes match - no differences found"));
        return true;
    }
    
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Root hashes differ - analyzing individual files"));
    
    // Step 6: Collect all files from both manifests
    TMap<FString, FString> LocalFiles;
    TMap<FString, FString> RemoteFiles;
    
    // Helper function to extract files from manifest recursively
    TFunction<void(TSharedPtr<FJsonObject>, const FString&, TMap<FString, FString>&)> ExtractFiles;
    ExtractFiles = [&ExtractFiles](TSharedPtr<FJsonObject> JsonObj, const FString& BasePath, TMap<FString, FString>& FileMap)
    {
        for (auto& Pair : JsonObj->Values)
        {
            if (Pair.Key == TEXT("Hash:"))
            {
                continue; // Skip hash fields
            }
            
            if (Pair.Value->Type == EJson::Object)
            {
                TSharedPtr<FJsonObject> SubObj = Pair.Value->AsObject();
                if (SubObj->HasField(TEXT("Files:")))
                {
                    // This is a directory with files
                    TSharedPtr<FJsonObject> FilesObj = SubObj->GetObjectField(TEXT("Files:"));
                    FString NewBasePath = BasePath.IsEmpty() ? Pair.Key : BasePath + TEXT("/") + Pair.Key;
                    ExtractFiles(FilesObj, NewBasePath, FileMap);
                }
                else
                {
                    // This might be a subdirectory
                    FString NewBasePath = BasePath.IsEmpty() ? Pair.Key : BasePath + TEXT("/") + Pair.Key;
                    ExtractFiles(SubObj, NewBasePath, FileMap);
                }
            }
            else if (Pair.Value->Type == EJson::String)
            {
                // This is a file hash
                FString FilePath = BasePath.IsEmpty() ? Pair.Key : BasePath + TEXT("/") + Pair.Key;
                FileMap.Add(FilePath, Pair.Value->AsString());
            }
        }
    };
    
    // Extract files from both manifests
    ExtractFiles(LocalContent, TEXT(""), LocalFiles);
    ExtractFiles(RemoteContent, TEXT(""), RemoteFiles);
    
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Local files: %d, Remote files: %d"), LocalFiles.Num(), RemoteFiles.Num());
    
    // Step 7: Compare files and identify differences
    TSet<FString> AllFiles;
    LocalFiles.GetKeys(AllFiles);
    
    TSet<FString> RemoteFileKeys;
    RemoteFiles.GetKeys(RemoteFileKeys);
    AllFiles.Append(RemoteFileKeys);
    
    for (const FString& FilePath : AllFiles)
    {
        FRSSFileDifference Difference;
        Difference.FilePath = FilePath;
        
        bool bExistsLocal = LocalFiles.Contains(FilePath);
        bool bExistsRemote = RemoteFiles.Contains(FilePath);
        
        if (bExistsLocal && bExistsRemote)
        {
            // File exists in both - compare hashes
            FString LocalHash = LocalFiles[FilePath];
            FString RemoteHash = RemoteFiles[FilePath];
            
            if (LocalHash != RemoteHash)
            {
                // Step 7a: Prioritize newer files (for now, prioritize remote)
                Difference.LocalHash = LocalHash;
                Difference.RemoteHash = RemoteHash;
                Difference.Action = TEXT("Update");
                Difference.Source = TEXT("Remote"); // Prioritize remote for now
                OutDifferences.Add(Difference);
                
                UE_LOG(LogTemp, Log, TEXT("RSSSync: File differs: %s"), *FilePath);
            }
        }
        else if (bExistsLocal && !bExistsRemote)
        {
            // File only exists locally - needs to be added to remote
            Difference.LocalHash = LocalFiles[FilePath];
            Difference.Action = TEXT("Add");
            Difference.Source = TEXT("Local");
            OutDifferences.Add(Difference);
            
            UE_LOG(LogTemp, Log, TEXT("RSSSync: Local-only file: %s"), *FilePath);
        }
        else if (!bExistsLocal && bExistsRemote)
        {
            // File only exists remotely - needs to be added to local
            Difference.RemoteHash = RemoteFiles[FilePath];
            Difference.Action = TEXT("Add");
            Difference.Source = TEXT("Remote");
            OutDifferences.Add(Difference);
            
            UE_LOG(LogTemp, Log, TEXT("RSSSync: Remote-only file: %s"), *FilePath);
        }
    }
    
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Found %d differences"), OutDifferences.Num());
    
    // Step 8: Save differences to JSON file if not executing changes
    if (!bExecuteChanges)
    {
        return SaveDifferencesToFile_UTIL(OutDifferences);
    }
    
    return true;
}

/**
 * Saves the differences analysis to RSSDifferences.json file.
 * 
 * @param Differences - Array of differences to save
 * @return bool - True if successfully saved
 */
bool SaveDifferencesToFile_UTIL(const TArray<FRSSFileDifference>& Differences)
{
    // Step 1: Create JSON structure for differences
    TSharedPtr<FJsonObject> RootObject = MakeShareable(new FJsonObject());
    TArray<TSharedPtr<FJsonValue>> DifferencesArray;
    
    // Step 2: Convert each difference to JSON
    for (const FRSSFileDifference& Diff : Differences)
    {
        TSharedPtr<FJsonObject> DiffObject = MakeShareable(new FJsonObject());
        DiffObject->SetStringField(TEXT("FilePath"), Diff.FilePath);
        DiffObject->SetStringField(TEXT("LocalHash"), Diff.LocalHash);
        DiffObject->SetStringField(TEXT("RemoteHash"), Diff.RemoteHash);
        DiffObject->SetStringField(TEXT("Action"), Diff.Action);
        DiffObject->SetStringField(TEXT("Source"), Diff.Source);
        DiffObject->SetStringField(TEXT("LastModified"), Diff.LastModified.ToString());
        
        DifferencesArray.Add(MakeShareable(new FJsonValueObject(DiffObject)));
    }
    
    RootObject->SetArrayField(TEXT("Differences"), DifferencesArray);
    RootObject->SetStringField(TEXT("CreatedDate"), FDateTime::Now().ToString());
    RootObject->SetNumberField(TEXT("DifferenceCount"), Differences.Num());
    
    // Step 3: Serialize and save
    FString OutputString;
    TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&OutputString);
    
    if (FJsonSerializer::Serialize(RootObject.ToSharedRef(), Writer))
    {
        FString SavePath = FPaths::ProjectDir() / TEXT("RSS") / TEXT("RSSDifferences.json");
        
        if (FFileHelper::SaveStringToFile(OutputString, *SavePath))
        {
            UE_LOG(LogTemp, Log, TEXT("RSSSync: Saved differences to: %s"), *SavePath);
            return true;
        }
    }
    
    UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to save differences file"));
    return false;
}

/*
==============================================================================
STEP 7: APPLY FILE CHANGES BASED ON DIFFERENCES
==============================================================================
*/

/**
 * Reads the RSSDifferences.json file and applies the necessary file operations.
 * Performs adding/overwriting actions based on the difference analysis.
 * 
 * @param DifferencesFilePath - Path to the RSSDifferences.json file
 * @param LocalDirectory - Local directory path for file operations
 * @param RemoteDirectory - Remote directory path for file operations
 * @return bool - True if all operations were successful
 */
bool ApplyFileChanges_UTIL(
    const FString& DifferencesFilePath,
    const FString& LocalDirectory,
    const FString& RemoteDirectory)
{
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Applying file changes from: %s"), *DifferencesFilePath);
    
    // Step 1: Load differences file
    FString JsonString;
    if (!FFileHelper::LoadFileToString(JsonString, *DifferencesFilePath))
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to load differences file"));
        return false;
    }
    
    // Step 2: Parse JSON
    TSharedPtr<FJsonObject> RootObject;
    TSharedRef<TJsonReader<>> Reader = TJsonReaderFactory<>::Create(JsonString);
    
    if (!FJsonSerializer::Deserialize(Reader, RootObject) || !RootObject.IsValid())
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to parse differences JSON"));
        return false;
    }
    
    // Step 3: Get differences array
    const TArray<TSharedPtr<FJsonValue>>* DifferencesArray;
    if (!RootObject->TryGetArrayField(TEXT("Differences"), DifferencesArray))
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: No differences array found"));
        return false;
    }
    
    // Step 4: Process each difference
    int32 SuccessCount = 0;
    int32 ErrorCount = 0;
    
    for (const TSharedPtr<FJsonValue>& DiffValue : *DifferencesArray)
    {
        TSharedPtr<FJsonObject> DiffObject = DiffValue->AsObject();
        if (!DiffObject.IsValid()) continue;
        
        FString FilePath = DiffObject->GetStringField(TEXT("FilePath"));
        FString Action = DiffObject->GetStringField(TEXT("Action"));
        FString Source = DiffObject->GetStringField(TEXT("Source"));
        
        UE_LOG(LogTemp, Log, TEXT("RSSSync: Processing %s - %s from %s"), *Action, *FilePath, *Source);
        
        // Step 5: Determine source and destination paths
        FString SourcePath, DestinationPath;
        
        if (Source == TEXT("Remote"))
        {
            SourcePath = RemoteDirectory / FilePath;
            DestinationPath = LocalDirectory / FilePath;
        }
        else // Local
        {
            SourcePath = LocalDirectory / FilePath;
            DestinationPath = RemoteDirectory / FilePath;
        }
        
        // Step 6: Execute the action
        bool bOperationSuccess = false;
        
        if (Action == TEXT("Add") || Action == TEXT("Update"))
        {
            // Ensure destination directory exists
            FString DestinationDir = FPaths::GetPath(DestinationPath);
            if (IFileManager::Get().MakeDirectory(*DestinationDir, true))
            {
                // Copy file from source to destination
                if (IFileManager::Get().Copy(*DestinationPath, *SourcePath, true, true))
                {
                    bOperationSuccess = true;
                    UE_LOG(LogTemp, Log, TEXT("RSSSync: Successfully copied: %s"), *FilePath);
                }
                else
                {
                    UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to copy file: %s"), *FilePath);
                }
            }
            else
            {
                UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to create directory: %s"), *DestinationDir);
            }
        }
        else if (Action == TEXT("Delete"))
        {
            // Delete file from destination
            if (IFileManager::Get().Delete(*DestinationPath, false, true))
            {
                bOperationSuccess = true;
                UE_LOG(LogTemp, Log, TEXT("RSSSync: Successfully deleted: %s"), *FilePath);
            }
            else
            {
                UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to delete file: %s"), *FilePath);
            }
        }
        
        if (bOperationSuccess)
        {
            SuccessCount++;
        }
        else
        {
            ErrorCount++;
        }
    }
    
    UE_LOG(LogTemp, Log, TEXT("RSSSync: File operations completed. Success: %d, Errors: %d"), 
           SuccessCount, ErrorCount);
    
    return ErrorCount == 0;
}

/*
==============================================================================
MAIN ORCHESTRATION FUNCTION
==============================================================================
*/

/**
 * Main function that orchestrates the entire RSS synchronization process.
 * This function ties together all the individual steps into a complete workflow.
 * 
 * @param RepositoryURL - GitHub repository URL (format: owner/repo)
 * @param BranchName - Name of the branch to synchronize
 * @param bExecuteChanges - Whether to actually apply changes or just analyze
 */
void ExecuteRSSSync_UTIL(
    const FString& RepositoryURL,
    const FString& BranchName,
    bool bExecuteChanges = false)
{
    UE_LOG(LogTemp, Log, TEXT("RSSSync: Starting synchronization process"));
    UE_LOG(LogTemp, Log, TEXT("Repository: %s, Branch: %s, Execute: %s"), 
           *RepositoryURL, *BranchName, bExecuteChanges ? TEXT("Yes") : TEXT("No"));
    
    // Step 1: Create temporary folder
    FString TempFolder = CreateRSSSyncTempFolder_UTIL();
    if (TempFolder.IsEmpty())
    {
        UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to create temporary folder"));
        return;
    }
    
    // Step 2: Download branch ZIP
    DownloadGitHubBranch_UTIL(RepositoryURL, BranchName, TempFolder,
        [=](bool bDownloadSuccess, const FString& ZipPath)
        {
            if (!bDownloadSuccess)
            {
                UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to download branch"));
                return;
            }
            
            // Step 3: Extract ZIP
            FString ExtractDir = TempFolder / TEXT("extracted");
            if (!ExtractBranchZip_UTIL(ZipPath, ExtractDir))
            {
                UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to extract branch ZIP"));
                return;
            }
            
            // Step 4: Create remote manifest
            FString RemoteManifestPath = ExtractDir / TEXT("RemoteRSSManifest.json");
            if (!CreateRemoteManifest_UTIL(ExtractDir, RemoteManifestPath))
            {
                UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to create remote manifest"));
                return;
            }
            
            // Step 5: Ensure local manifest exists
            if (!EnsureLocalManifestExists_UTIL())
            {
                UE_LOG(LogTemp, Error, TEXT("RSSSync: Local manifest is required but not found"));
                return;
            }
            
            // Step 6: Compare manifests
            TArray<FRSSFileDifference> Differences;
            FString LocalManifestPath = FPaths::ProjectDir() / TEXT("RSS") / TEXT("RSSManifest.json");
            
            if (!CompareManifests_UTIL(LocalManifestPath, RemoteManifestPath, bExecuteChanges, Differences))
            {
                UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to compare manifests"));
                return;
            }
            
            if (Differences.Num() == 0)
            {
                UE_LOG(LogTemp, Log, TEXT("RSSSync: No differences found - repositories are in sync"));
                return;
            }
            
            // Step 7: Apply changes if requested
            if (bExecuteChanges)
            {
                FString LocalDir = FPaths::ProjectDir() / TEXT("Macros"); // Adjust as needed
                
                if (!ApplyFileChanges_UTIL(
                    FPaths::ProjectDir() / TEXT("RSS") / TEXT("RSSDifferences.json"),
                    LocalDir, ExtractDir))
                {
                    UE_LOG(LogTemp, Error, TEXT("RSSSync: Failed to apply file changes"));
                    return;
                }
                
                UE_LOG(LogTemp, Log, TEXT("RSSSync: File synchronization completed successfully"));
            }
            else
            {
                UE_LOG(LogTemp, Log, TEXT("RSSSync: Analysis complete. %d differences found and saved to RSSDifferences.json"), 
                       Differences.Num());
            }
        }
    );
}

/*
==============================================================================
USAGE EXAMPLES AND INTEGRATION GUIDE
==============================================================================

BASIC USAGE:
1. To analyze differences only:
   ExecuteRSSSync_UTIL("owner/repository", "main", false);

2. To synchronize and apply changes:
   ExecuteRSSSync_UTIL("owner/repository", "main", true);

INTEGRATION WITH EXISTING SYSTEM:
1. Add this file to your project's Private folder
2. Include the header in files that need RSS sync functionality
3. Ensure all external dependencies are available
4. Call ExecuteRSSSync_UTIL() from your UI or Blueprint events

REQUIRED GITHUB SETUP:
1. Create a Personal Access Token with repo permissions
2. Ensure the repository is accessible with the token
3. Consider using GitHub Apps for better security in production

ERROR HANDLING:
- All functions include comprehensive error logging
- Check UE logs for detailed error information
- Functions return boolean success indicators
- Implement retry logic for network operations as needed

PERFORMANCE CONSIDERATIONS:
- Large repositories may take significant time to download/process
- Consider implementing progress callbacks for UI feedback
- ZIP operations are CPU intensive - avoid blocking game thread
- Network operations should be async (already implemented)

SECURITY NOTES:
- Store GitHub tokens securely (not in plain text)
- Validate all file paths to prevent directory traversal
- Consider file size limits for uploads
- Implement proper authentication for production use

==============================================================================
*/
